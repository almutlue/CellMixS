% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evalIntegration.R
\name{evalIntegration}
\alias{evalIntegration}
\title{evalIntegration}
\usage{
evalIntegration(metric, sce, group, dim_red = "PCA",
  assay_name = "logcounts", n_dim = 10, res_name = NULL, k = NULL,
  k_min = NULL, smooth = NULL, cell_min = NULL, k_pos = NULL,
  sce_pre_list = NULL, dim_combined = NULL, assay_pre = NULL,
  n_dim_orig = NULL, BPPARAM = SerialParam())
}
\arguments{
\item{metric}{Character. Name of the metric to apply. Must be one of 'cms',
'ldfDiff', 'lisi', 'mixing_metric', 'local_structure', 'entropy'.}

\item{sce}{\code{SingleCellExperiment} object, with the integrated data.}

\item{group}{Character. Name of group/batch variable.
Needs to be one of \code{names(colData(sce))}.}

\item{dim_red}{Character. Name of embeddings to use as subspace for distance
distributions. Default is "PCA".}

\item{assay_name}{Character. Name of the assay to use for PCA.
Only relevant if no existing 'dim_red' is provided.
Must be one of \code{names(assays(sce))}. Default is "logcounts".}

\item{n_dim}{Numeric. Number of dimensions to include to define the subspace.}

\item{res_name}{Character. Appendix of the result score's name
(e.g. method used to combine batches).}

\item{k}{Numeric. Number of k-nearest neighbours (Knn) to use.}

\item{k_min}{Numeric. Minimum number of Knn to include
(see \code{\link{cms}}). Relevant for metrics: 'cms'.}

\item{smooth}{Logical. Indicating if cms results should be smoothened within
each neighbourhood using the weigthed mean. Relevant for metrics: 'cms'.}

\item{cell_min}{Numeric. Minimum number of cells from each group to be
included into the AD test. Should be > 4. Relevant for metric: 'cms'.}

\item{k_pos}{Numeric. Position of cell to be used as reference within mixing
metric. See \code{\link[Seurat]{MixingMetric}} for details.
Relevant for metric: 'mixing_metric'}

\item{sce_pre_list}{A list of \code{SingleCellExperiment} objects with single
datasets before integration. Names should correspond to levels in
\code{colData(sce_combined)[,group]}. Relevant for metric: 'ldfDiff'}

\item{dim_combined}{Character. Name of embeddings to use as subspace to
calculate LDF after integration. Default is \code{dim_red}.
Relevant for metric 'ldfDiff'.}

\item{assay_pre}{Character. Name of the assay to use for PCA.
Only relevant if no existing 'dim_red' is provided.
Must be one of \code{names(assays(sce_pre))}. Default is "logcounts".
Relevant for metric 'ldfDiff'.}

\item{n_dim_orig}{Number of PCs to use in original space.
See \code{\link[Seurat]{LocalStruct}} for details.
Relevant for metric 'local_structure'.}

\item{BPPARAM}{A \linkS4class{BiocParallelParam} object specifying whether
cms scores shall be calculated in parallel. Relevant for metric: 'cms'.}
}
\value{
A \code{SingleCellExperiment} with the chosen metric's score within
colData.
}
\description{
Function to evaluate sc data integration providing a framework for different
metrics. Metrics to evaluate mixing and preservance of the local/individual
structure are provided.
}
\details{
evalIntegration is a wrapper function for different metrics to
understand results of integrated single scell data sets.
In general there are metrics evaluationg the *mixing* of datasets.
So metrics that show whether there still is a bias for different datasets
after integration. Furthermore there are metrics to evaluate how well the
dataset intenal structure has been retained. So metrics that show whether
there has been (potentially biological) signal removed or noise added by
integration.
}
\examples{
library(SingleCellExperiment)
sim_list <- readRDS(system.file("extdata/sim50.rds", package = "CellMixS"))
sce <- sim_list[[1]][, c(1:15, 400:420, 16:30)]
sce_batch1 <- sce[,colData(sce)$batch == "1"]
sce_batch2 <- sce[,colData(sce)$batch == "2"]
pre <- list("1" = sce_batch1, "2" = sce_batch2)

sce <- evalIntegration("cms", sce, "batch", k = 20)
sce <- evalIntegration("lisi", sce, "batch", k = 20)
sce <- evalIntegration("mixing_metric", sce, "batch", k = 20)
sce <- evalIntegration("entropy", sce, "batch", k = 20)
sce <- evalIntegration("ldfDiff", sce, "batch", k = 20, sce_pre_list = pre)
sce <- evalIntegration("local_structure", sce, "batch", k = 10, n_dim = 2, n_dim_orig = 2)

}
\references{
Korsunsky I Fan J Slowikowski K Zhang F Wei K et. al. (2018).
Fast, sensitive, and accurate integration of single cell data with Harmony.
bioRxiv (preprint).

Stuart T Butler A Hoffman P Hafemeister C Papalexi E et. al. (2019)
Comprehensive Integration of Single-Cell Data.
Cell.
}
